## Задача 1 - students_dictionary
Дефинирајте речник students во кој ќе се чуваат информации за предметите кои ги полагале студентите. Од стандарден влез се читаат информации за име, презиме, број на индекс, предмет, поени од теоретски дел, поени од практичен дел и поени од лабораториски вежби. Може да се вчитаат информации за неограничен број студенти. Вчитувањето информации завршува кога ќе се прочита клучниот збор end. Пополнете го речникот students со вчитаните информации.
Потоа, за секој од студентите да се испечати името и презимето, и оцената за секој од предметите кои ги има полагано.
Оцената се пресметува на следниот начин:

[0, 50] - 5

(50, 60] - 6

(60, 70] - 7

(70, 80] - 8

(80, 90] - 9

(90, 100] - 10

````
Input:

Alice,Doe,141414,Artificial Intelligence,40,40,5
Alice,Doe,141414,Machine Learning,30,40,10
Lewis,Smith,141415,Robotics,40,30,10
Lewis,Smith,141415,Bioinformatics,40,30,10
George,Williams,123456,Artificial Intelligence,20,40,9
James,Brown,123457,Artificial Intelligence,25,30,3
William,Williams,123458,Artificial Intelligence,10,45,8
Elle,Brown,123459,Artificial Intelligence,45,10,7
end
````
````
Expected:

Student: Alice Doe
----Artificial Intelligence: 9
----Machine Learning: 8

Student: Lewis Smith
----Robotics: 8
----Bioinformatics: 8

Student: George Williams
----Artificial Intelligence: 7

Student: James Brown
----Artificial Intelligence: 6

Student: William Williams
----Artificial Intelligence: 7

Student: Elle Brown
----Artificial Intelligence: 7
````

## Задача 2 - minesweeper
Овој проблем се базира на играта Minesweeper.

Креирајте функција која како влез зема листа од # и -, каде што секој хаш знак (#) претставува мина, а секоја цртичка (-) претставува поле без мина. Функцијата треба да враќа листа каде што секоја цртичка е заменета со бројка која го претставува бројот на мини од најблиските полиња на моменталното поле (хоризонтално, вертикално, и дијагонално). Листата која се враќа на излез креирајте ја со пристапот list comprehension.

Од стандарден влез е дадена големината на полето N (полето е со димензии NxN), како и репрезентацијата на полето со # и -. Потребно е да направите репрезентација на полето преку листа од листи, каде што елементите се # и -. Оваа листа е влез на претходно дефинираната функција, а излезот од функцијата е потребно да се испечати од стандарден влез.

Помош: влезот е зададен ред по ред за секоја редица во полето, додека индивидуалните елементи се одвоени со 3 празни места. За да се одделат елементите со 3 празни места, може да ја искористите функцијата split() дефинирана на стрингови. За печатење на излезот може да ја користите функцијата join() дефинирана на стрингови.

````
Input:
5
-   -   -   -   -
-   -   -   -   -
-   -   #   -   -
-   -   -   -   -
-   -   -   -   -
````
````
Expected:
0   0   0   0   0
0   1   1   1   0
0   1   #   1   0
0   1   1   1   0
0   0   0   0   0
````

## Задача 3 - pacman
Во овој проблем ќе ја имплементирате играта Pacman. Оваа игра се игра така што имате едно човече кое се движи низ просторот и целта е да ги изеде сите точки притоа избегнувајќи чудовишта. Видео кое ќе ве запознае со играта: https://www.youtube.com/watch?v=i_OjztdQ8iw. Притоа во нашиот пример е поедноставена оваа игра така што секогаш ќе имате правоаголни форми и не треба да избегнувате чудовишта. Целта на оваа поедноставена игра е да се изедат сите точки во просторот.

Креирајте класа Player која го означува играчот во играта. Во оваа класа треба да ги чувате моменталните позиции на играчот во играта (x и y координати). Оваа класа има метода move(position) што означува придвижување на играчот на дадената позиција. Потоа креирајте класа Game која ќе ја означува моменталната игра. Во оваа класа треба да го чувате просторот на игра (матрица) и притоа може да си чувате и помошни вредности. За крај креирајте класа Pacman во која ќе чувате инстанца од класата Player и класата Game. Во оваа класа треба да имате една метода play_game() во која треба да ја имплементирате логиката за играта. Почетната позиција на играчот е (0,0). Играчот може да се движи горе, долу, лево или десно. Притоа ако во некоја можна позиција каде може да се придвижи играчот има точка тогаш таа позиција е посакуваната позиција каде треба да се придвижи. Ако има повеќе позиции каде има точки, во тој случај играчот избира случајно каде да се придвижи. Ако во ниедна можна позиција нема точки, тогаш пак играчот избира случајно на која позиција ќе се придвижи. Играта завршува кога нема преостанати точки кои треба да ги изеде играчот.

Влез: На влез прво добивате ширина и висина на просторот за игра. Потоа во секој нареден ред добивате состојбата на редот од просторот. Притоа секоја позиција се означува со # што означува празно поле и . што означува дека во полето има точка.

Излез: На излез се печати секој чекор кој го направил играчот се додека не ги изел сите точки. Доколку во просторот за игра нема ниту една точка, се печати „Nothing to do here“.

Напомена: За да симулирате случајно придвижување може да го користите модулот random. Метода која генерира случаен број во даден ранг е randint(range_from,range_to). Може да користите и дополнителни методи од овој модул кои може да ги најдете во документација. Бидејќи работиме со случајни придвижувања, НЕ МОРА тест примерите да ви поминуваат, туку се само за ваше тестирање.
````
Input:
5
5
##.##
..#..
.###.
.....
#..#.
````
````
Expected:
[1, 0]
[1, 1]
[2, 1]
[2, 0]
[3, 0]
[3, 1]
[3, 2]
[3, 3]
[3, 4]
[4, 4]
[3, 4]
[2, 4]
[1, 4]
[1, 3]
[1, 4]
[1, 3]
[0, 3]
[0, 2]
[1, 2]
[2, 2]
[2, 3]
[2, 2]
[3, 2]
[4, 2]
[4, 1]
````